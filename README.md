VOCLE

Collaborators: N/A

Overview: Vocle is a song-guessing game inspired by Heardle, with multiplayer and singleplayer options, that will play a snippet of a song either from our default playlist(the most popular current songs) or by importing a Spotify playlist by copying the url. The multiplayer game can be played by up to 4 players on the same laptop using the keys q, m, p, and z. Additionally, the singleplayer game allows up to 6 tries to guess the right answer, including a skip button if the user wants to skip to the next guess. For singleplayer, the time increment of the snippet increases for every guess, while in multiplayer the song plays for 30 seconds. 

Design Choices:

Frontend:

All files were imported from Figma to HTML and CSS, using the react libraries of useNavigate and setState to be able to open overlays and navigate between the main pages of Home, Singleplayer, and Multiplayer. We decided to create overlays because it was uneccessary to create an entirely new page for a new command input, allowing the user to backtrack his steps easily if necessary, creating a simple user interface. 

To be able to access information between classes, along with inputting information into the several exportable functions created, such as AddGuessMultiplayer, Timer, and the About modals, we nested classes within the singleplayer, home, and multiplayer to create easy accessibility and connection between the classes. Additionally, for the information that was hard to access using this method, we added Ids to certain css elements to be able to call them and access their text content, which became useful in accessing the dropdown data when the submit button was clicked, along with bringing the user to the game over screen when the timer reached 0 seconds. Additionally, we decided to use a combination of js and ts files, depending on if we needed to know the types of certain elements. This was especially useful for accessing the textContent through an css Id element. On top of that, to avoid confusion between classes, we created separate classes for single player and multiplayer elements including timer and overlays since the inputs or functionality differed, while keeping elements such as the dropdown menu, and submit buttons the same. Additionally, to avoid any confusion in multiplayer for which user clicked the key first and should input their guess, a key input of either q,p,m, or z will create a message to appear on the screen indicating which user should input their guess based off of which key was clicked first. For multiplayer, no user should be able to pause the song while it is playing, so we decided to remove the play/pause button when clicked at the beginning to avoid this occurrence. For both the singleplayer and multiplayer, incorrect guesses show up red and skips show up white to inform the user the result of their input. For a correct guess, the game over page is shown. Also on the game over page, the user is able to play again or return home to input a new playlist of their choosing or play with the default playlist, removing the need to refresh the page or having to self navigate to another page on the screen. 

In addition, we limited the user interface to avoid scrollability, creating a webpage which looks much nicer and avoids the added trouble of needing to scroll up or down to access different elements.

It should be also noted that we decided to wrap the Map containing the details of our requests to the backend in the `resultMap.tsx` class. The intentions behind this were to give all of our classes a way to access the data when checking answers, generating options for the dropdown, getting the audio URL, etc. and by wrapping this data in the `resultMap.tsx` class it allowed all of our classes to access this data. We also added the `setResultMap` method to allow classes that needed to, such as the `GameOver.tsx` class to reset the data and generate a new track when the playAgain button is clicked and update the Map to allow all the other classes to update their data for the new iteration of the game with a new song. 

Backend:

The backend is an API Server that consists of two endpoints `SpotifyToken` and `GenerateTrack`. 

The `SpotifyToken` endpoint takes in no parameters and returns a JSON containing a `Result` field mapping to the value `Invalid Parameters` in the event of parameters and in the event of a success returns a JSON containing a `Result`, `ExpiresIn`, and `AccessToken` field. The `AccessToken` is the actual token that can be used to extract data from the SpotifyAPI and the `ExpiresIn` is the duration of the token. The token is generated by sending a `POST` request to the SpotifyAPI using the client credentials generated when registering our app with the SpotifyAPI and then reading in the bytes returned by the `POST` request to extract the accessToken and the duration of the token. In the event of a failure to connect to the SpotifyAPI or if an error occurs while generating the token an error message is displayed via the `Result` field; however, this should never be the case.

The `GenerateTrack` endpoint takes in two parameters, `accessToken` which is a valid AccessToken that was given by the SpotifyAPI and `playlistID` which is the ID of a public spotify playlist. The reason we chose to make it take in `playlistID` as opposed to `playlistURL` is because our frontend's `generateTrack` method already handles parsing the `playlistURL` into the `playlistID` which is then sent to the backend via a `fetch` request. The `GenerateTrack` endpoint given these two parameters is responsible for returning a JSON containing a `Result` field, `TrackURL` which is a URL to the preview of the randomly generated track `TrackName` which is the name of the randomly generated track `ArtistName` which is the name of the artist of the randomly generated track `TrackandArtistsList` which returns a List of all the songs and artists on the playlist with each element of the List being in the form `*trackname* - *artistname*`, `AlbumURL` which is the URL that leads to the album cover of the randomly generated track, `Track Answer` which is the randomly generated track in the form `*trackname* - *artistname*`, and `PlaylistID` which contains the playlistID of the Spotify playlist from which these details were generated. In the event of an invalid playlistID or an invalid accessToken the backend fails to connect to the SpotifyAPI so it returns an error code to our backend, in this event we return `Invalid Playlist` in the `Result` field which is intended, since we are under the assumption that when people use the `GenerateTrack` endpoint they have generated a valid accessToken using our `SpotifyToken` endpoint or have already generated a valid accessToken themselves, thus we are not concerned about the validity of the accessToken but whether the playlist is a public playlist that we can access via the SpotifyAPI. 

Errors/Bugs: N/A


Tests:

Frontend: the frontend tests written test if the site, the singleplayer and multiplayer along with all additional components appear in the HTML document when rendering the site. The submit button is tested as well to ensure that the submit button is rendered correctly when accessing the drop down menu information and displaying the guess component onto the screen. The play button for the multiplayer gamemode is also tested to see if it times out properly after 30 seconds and displays the Game Over screen.

Backend:

The backend tests were written to test the validity of our endpoints accounting for the scenarios that our frontend may encounter. Thus we test our two endpoints the `SpotifyToken` and the `GenerateTrack` endpoint. The `SpotifyToken` endpoint simply tests if valid and invalid parameters are inputted. This is because in theory the `SpotifyToken` endpoint should always work since it generates a request from the SpotifyAPI which is always running so if a valid request is made, which is handled in the code of our backend a valid accessToken should always be returned. The `GenerateTrack` tests essentially test for the cases where valid parameters are inputted and then invalid accessTokens and invalid playlistIDs are given. This is to ensure that the endpoint works as intended for our frontend and catches when invalid playlistIDs and accessTokens are given so that way our frontend can appropriately understand that an invalid playlistID was inputted and appropriately return the error message for the user to understand. We built the tests around how integration works with our frontend and that is why we display the same error message for both an invalid accessToken and invalid playlistID, since the end-user never deals with the accessToken. 

How to run tests:

Navigate to the frontend directory of the project by using the command cd frontend and then running the command `npm test`

In the backend run `mvn package` to compile the program and then `mvn test` to run the tests. 

How to run the program:

Open the backend in Intellij and run Server while in VSCode, navigate to your frontend using cd frontend and running the command npm start. 


